Sphere Runtime API Reference
============================

Besides the low-level Core API, the Sphere platform also includes a set of
standard objects used for higher-level tasks, collectively known as the
Sphere Runtime.  This file documents the API.


`BinaryCoder` Object
--------------------

A `BinaryCoder` object allows reading and writing structured binary data from
a file or socket.  The idea is similar to the built-in TextEncoder/TextDecoder
classes, but for general binary data instead of text.

    import { BinaryCoder } from 'sphere-runtime';

BinaryCoder supports numeric values encoded in both big-endian (most
significant byte first) and little-endian (least significant byte first) modes.
Big-endian mode is the default, as this is the de facto standard byte order for
data interchange.

new BinaryCoder(stream[, options]);

    Constructs a `BinaryCoder` object which can be used to read binary data
    from the specified stream.  `options` specifies the default behavior for
    this BinaryCoder.

    options.little_endian [default: false]

        Whether to use little-endian mode by default when reading and writing
        numeric values.  As big-endian is the de facto standard byte order for
        data interchange, the default for this option is `false`.

    options.nulTermination [default: false]

        Whether strings encoded and decoded by this BinaryCoder should end with
        a NUL terminator ('0' byte) by default.  If this is true, strings read
        by the BinaryCoder will be truncated at the first NUL byte and any
        strings written will have a NUL byte appended when written out.

BinaryCoder#readBytes(stream, num_bytes);

    Reads `num_bytes` from a stream and returns a Uint8Array containing all the
    bytes read.

BinaryCoder#readFloat32(stream[, little_endian]);
BinaryCoder#readFloat64(stream[, little_endian]);

    Reads a 32-bit (single precision) or 64-bit (double precision) IEEE
    floating value from a stream.

BinaryCoder#readInt8(stream);
BinaryCoder#readInt16(stream[, little_endian]);
BinaryCoder#readInt32(stream[, little_endian]);
BinaryCoder#readUint8(stream);
BinaryCoder#readUint16(stream[, little_endian]);
BinaryCoder#readUint32(stream[, little_endian]);

    Reads an 8-, 16-, or 32-bit twos'-complement integer value from a stream.

    Note: `readUint` variants write unsigned values (always positive).
          `readInt` variants write signed values (positive or negative).

BinaryCoder#readString(stream, numBytes[, nul_terminate]);

    Reads a fixed-length UTF-8 string from a stream.  Use this only when you
    know the length of the string in advance; otherwise, the length is probably
    encoded in the data and you should use one of the variable-sized versions
    below.

BinaryCoder#readString8(stream[, nul_terminate]);
BinaryCoder#readString16(stream[, nul_terminate[, little_endian]]);
BinaryCoder#readString32(stream[, nul_terminate[, little_endian]]);

    Reads a UTF-8 variable-length string from a stream, where the length of the
    string in bytes is stored as an unsigned integer immediately before the
    character data.

BinaryCoder#readStruct(stream, desc);

    Reads several values from a stream sequentially based on a data descriptor.
    `desc` is an object describing the data type of each item; for example,
    the following will read the 256-byte header from a Sphere v1 format map
    file (assuming a BinaryCoder in little-endian mode):

        rmp_header = myReader.readStruct({
            signature: 'string/4',
            version: 'uint16',
            type: 'uint8',
            numLayers: 'uint8',
            reserved1: 'raw/1',
            numEntities: 'uint16',
            startX: 'uint16',
            startY: 'uint16',
            startLayer: 'uint8',
            startDir: 'uint8',
            numStrings: 'uint16',
            numZones: 'uint16',
            repeating: 'bool',
            reserved2: 'raw/234',
        });

    `readStruct` returns an object where each property named in `desc` is set
    to the value read for that entry.  It is recommended to pass an object
    literal for `desc` (as illustrated above) to ensure values will be read in
    the correct order.

    Each property in `desc` must be set to one of the following strings,
    otherwise an exception will be thrown:

        "bool"        - Boolean value, stored as 1 byte (`true`/`false`)
        "float32-be"  - Floating point, 32-bit, big endian
        "float32-le"  - Floating point, 32-bit, little endian
        "float64-be"  - Floating point, 64-bit, big endian
        "float64-le"  - Floating point, 64-bit, little endian
        "int8"        - 8-bit signed int [-128, +127]
        "int16-be"    - 16-bit signed int, big endian [-32768, +32767]
        "int16-le"    - 16-bit signed int, little endian [-32768, +32767]
        "int32-be"    - 32-bit signed int, big endian [-2147483648, +2147483647]
        "int32-le"    - 32-bit signed int, little endian [-2147483648, +2147483647]
        "raw/<n>"     - Raw data (ArrayBuffer), <n> is number of bytes
        "string/<n>"  - UTF-8 string, <n> is number of bytes stored
        "string8"     - 8-bit unsigned byte count + UTF-8 string
        "string16-be" - 16-bit unsigned byte count + UTF-8 string, big endian
        "string16-le" - 16-bit unsigned byte count + UTF-8 string, little endian
        "string32-be" - 32-bit unsigned byte count + UTF-8 string, big endian
        "string32-le" - 32-bit unsigned byte count + UTF-8 string, little endian
        "uint8"       - 8-bit unsigned int [0, 255]
        "uint16-be"   - 16-bit unsigned int, big endian [0, 65535]
        "uint16-le"   - 16-bit unsigned int, little endian [0, 65535]
        "uint32-be"   - 32-bit unsigned int, big endian [0, 4294967295]
        "uint32-le"   - 32-bit unsigned int, little endian [0, 4294967295]

BinaryCoder#writeFloat32(stream, value[, little_endian]);
BinaryCoder#writeFloat64(stream, value[, little_endian]);

    Writes a 32-bit (single precision) or 64-bit (double precision) floating
    point value to a stream.

BinaryCoder#writeInt8(stream, value);
BinaryCoder#writeInt16(stream, value[, little_endian]);
BinaryCoder#writeInt32(stream, value[, little_endian]);
BinaryCoder#writeUint8(stream, value);
BinaryCoder#writeUint16(stream, value[, little_endian]);
BinaryCoder#writeUint32(stream, value[, little_endian]);

    Writes an 8-, 16-, or 32-bit twos'-complement integer value to a stream.

    Note: `writeUint` variants write unsigned values (always positive).
          `writeInt` variants write signed values (positive or negative).

BinaryCoder#writeString(stream, value[, nul_terminate]);

    Writes a UTF-8 string a stream.

    Note: The length of the string is not stored.  If you need to know the
          length of a string when reading back the data later, use one of the
          variable-sized versions below.

BinaryCoder#writeString8(stream, value);
BinaryCoder#writeString16(stream, value[, nul_terminate[, little_endian]]);
BinaryCoder#writeString32(stream, value[, nul_terminate[, little_endian]]);

    Writes a UTF-8 length-prefixed string to a stream.  The length in bytes is
    stored as an unsigned integer immediately before the character data.


`Console` Object
----------------

The `Console` object provides a way to add a text-based debug console to your
game.  A full command parser is built in, so the only thing your game needs to
do is provide names and implementations for supported console commands.  Sphere
will do the rest.

During gameplay, if the game has created at least one Console, it can be shown
and hidden by the player using a hotkey (`~` by default).

    import { Console } from 'sphere-runtime';

new Console(options);

    Constructs a new Console and starts it running, enabling the player to
    access it while in-game.  `options` is an object specifying the settings
    for the new console.

    options.hotKey [default: Key.Tilde]

        A `Key` value specifying which keyboard key will show and hide the
        console.

    options.logFileName [default: none]

        The SphereFS path of the file used for logging console output.  If
        not provided, no log file will be created.  Note that if the log
        file already exists, it will be appended to instead of being
        overwritten.

    options.prompt [default: "$"]

        A string specifying the text to display in front of the command
        line.

Console#visible [R/W]

    Gets or sets whether this Console is visible to the player.  Setting this
    to `true` will show the console, while setting to `false` will hide it.

Console#defineObject(objectName, thisObj, commands);

    Registers an object and a set of commands with this Console.  `commands` is
    an object providing the names and implementations of the commands being
    added, which will be associated with the name specified by `objectName`.
    Each property of `commands` has as its key the command name, and a function
    as its value, which will be called when the command is invoked.  `thisObj`
    specifies a `this` binding to use when calling a command function.

    As this API is complex and difficult to explain, an example might help
    illuminate things.  A sample `Console#defineObject` call might look
    something like this:

        console.defineObject('sound', null, {
            'play': function(filename) {
                if (fs.exists(filename)) {
                    new Sound(filename).play(Mixer.Default);
                }
            }
        });

    The player could then type `sound play sounds/munch.wav` into the console
    to play that sound (assuming it exists).  Note that if an error is thrown
    while processing a command, the console will not catch it.  Games should
    perform some form of error checking in their command functions to prevent
    the player from destabilizing the game.

Console#log(text[, text2[, ...]]);

    Logs a line of text to this console.  Passing more than one value will
    cause the strings to be separated with chevrons (`>>`).

Console#undefineObject(objectName);

    Unregisters all commands previously registered under `objectName` for this
    Console.  See `Console#defineObject()` for more information.

    Note: It is not currently possible to unregister individual commands.


`FocusTarget` Object
--------------------

The `FocusTarget` object provides a simple way to manage input focus.  Only a
single target can be in focus at any given moment, and each target can be given
a priority value to prevent low-priority targets from stealing focus from more
important ones.

    import { FocusTarget } from 'sphere-runtime';

new FocusTarget(options);

    Constructs a new focus target.  To prevent confusing focus switches, the
    new target is not given focus initially; you must explicitly call
    `Focus#take()` when you want to give it focus.

    options.priority [default: 0.0]

        The priority of the target.  Priority is used to control the behavior
        when another target tries to take the focus via `Focus#take()` (see
        below).

FocusTarget#hasFocus [R/O]

    `true` if the target is currently in focus, `false` otherwise.

FocusTarget#dispose();

    Disposes of the FocusTarget object.  YOu should call this when the target
    is no longer needed, in order to clear it from the focus queue.  This also
    yields focus if the object was in focus at the time.

FocusTarget#takeFocus();

    Takes focus.  If a higher-priority object already has focus, this one will
    not receive focus until the higher-priority one yields.  This prevents
    focus from being stolen from a higher-priority target.

FocusTarget#yield();

    Yields the focus.  If the target is not in focus, this does nothing.


`Logger` Object
---------------

The `Logger` object provides basic logging functionality.  Your game can use
this to log lines of text to a file--complete with timestamps for each--which
is often very useful for debugging purposes.

    import { Logger } from 'sphere-runtime';

new Logger(filename);

    Opens the specified file for logging.  If the file cannot be opened for
    writing, an error is thrown.

    Note: `fileName` is relative to `~/logFiles` unless it includes a SphereFS
          prefix.  If it doesn't include a prefix, ".log" is appended to the
          filename automatically.

Logger#beginGroup(text);

    Begins an group.  All log entries in a group will be indented.  Groups can
    be nested.

Logger#endGroup();

    Closes the most recently opened group.  There should be a corresponding
    endGroup() for each beginGroup() call.

Logger#write(text);

    Writes a timestamped entry to the log.  `text` should contain no newline
    characters, although this is not enforced.


`Music` Namespace
-----------------

A flexible system based on Audialis for managing playback of background music.
The design, based on a pushdown stack, integrates well with finite state
machine architectures, which are often themselves based on a stack of states.
Code can push new BGM to the music stack, and when it is later popped, the
previous track resumes right where it left off.

The Music engine supports crossfading, which helps smooth out BGM transitions.
The music stack can also be bypassed when needed, from simply switching out the
song on top of the stack with another track, to overriding the contents of the
stack entirely, which is often useful in RPGs to override the battle music for
story reasons.

    import { Music } from 'sphere-runtime';

Music.adjustVolume(newVolume, time);

    Smoothly adjusts the BGM volume level and returns a promise that resolves
    when the adjustment is complete.  Works with `await`.  `newVolume` should
    be a value between 0 and 1, where 0 is silent and 1 is full volume.  `time`
    is the amount of game time the adjustment should take, in frames.

Music.override(fileName[, fadeTime]);

    Overrides the BGM stack by playing the track specified by `fileName` at all
    times.  One example use is in RPGs, e.g. to override the battle music
    during an important storyline event.  `fadeTime` is the amount of crossfade
    to apply, in frames.

    Overriding the BGM doesn't prevent music stack tracking.  Once the override
    is cancelled (by calling `reset()`), the song on top of the stack at that
    time will resume playback.

    Note: `fileName` is relative to `@/music` unless it includes a SphereFS
          prefix.  The file extension is optional; if no extension is included,
          Sphere will find an appropriate file automatically.

Music.play(fileName[, fadeTime]);

    Replaces the song on top of the music stack with the track named by
    `fileName`.  This is not an override; if `play()` or `push()` is called
    afterwards, the BGM will change.  `fadeTime` is the amount of crossfade to
    apply, in frames.

    Note: `fileName` is relative to `@/music` unless it includes a SphereFS
          prefix.  The file extension is optional; if no extension is included,
          Sphere will find an appropriate file to play automatically.

Music.pop([fadeTime]);

    Pops the topmost song off the music stack.  This will resume playing
    whatever song was playing when the corresponding push() was done.

Music.push(fileName[, fadeTime]);

    Pushes a new song to the music stack.  If pop() is called later, the
    previous BGM will resume from where it left off.  `fadeTime` is the amount
    of crossfade to apply, in frames.

    Note: `fileName` is relative to `@/music` unless it includes a SphereFS
          prefix.  The file extension is optional; if no extension is included,
          Sphere will find an appropriate file to play automatically.

Music.reset([fadeTime]);

    Resets the BGM manager to normal operation, removing any outstanding
    overrides.  `fadeTime` is the amount of crossfade to apply, in frames.


`Pact` Object
-------------

Promises, the mechanism underlying asynchronous functions in JavaScript, are a
powerful construct but can be difficult to work with.  A promise represents the
future result of some ongoing task which will eventually settle it; outside
code can only observe the promise and await its resolution.

Normally, a Promise can only be settled from within the function passed to the
`Promise` constructor.  This makes managing custom promises awkward--and that's
where `Pact` comes in.  Pact provides a means to set up a promise which can
later be settled by any code that holds a reference to the pact.  In this way
the opacity of the Promise object is maintained while keeping things simple for
the code handing them out.

    import { Pact } from 'sphere-runtime';

Pact.reject([reason]);

    Constructs a new pact whose promise is immediately settled with a rejection
    value of `reason`.  The promise rejects with a value of `undefined` if no
    reason is provided.

Pact.resolve([result]);

    Constructs a new pact whose promise is immediately settled with a
    resolution value of `result`.  The promise resolves with a value of
    `undefined` if no value is provided.

new Pact();

    Constructs a new pact.  The pact encapsulates a promise which can be
    settled by calling either `Pact#resolve()` or `Pact#reject()`.

Pact#reject([reason]);

    Settles `promise` with a rejection value of `reason` (typically this is a
    JavaScript Error object, although this is not enforced).  If no reason is
    provided, the promise will settle with a rejection value of `undefined`.

    Note: If this pact's promise has already been settled, calling this method
          has no effect.

Pact#resolve([result]);

    Settles the promise with a fulfillment value of `result`.  The result can
    be any JavaScript value or object.  If no result value is provided, the
    promise will settle with a resolution value of `undefined`.

    Note: If this pact's promise has already been settled, calling this method
          has no effect.

Pact#toPromise();

    Returns a standard Promise which resolves to the same value as this pact.
    Use this when you want to provide outside code with access to the pact's
    resolution or rejection value without also giving access to the settlement
    methods described above.


`Prim` Namespace
----------------

The `Prim` namespace provides convenience functions for drawing common graphics
primitives such as circles and rectangles, which are tedious to render using
the Core API directly.

    import { Prim } from 'sphere-runtime';

Prim.blit(surface, x, y, texture[, mask]);

    Draws the specified texture as a plain image.  `mask` gets multiplied into
    each texel and has the effect of tinting the rendered image.  If no mask is
    specified, `Color.White` is assumed, which leaves the image as-is.

Prim.blitSection(surface, x, y, texture, sx, sy, width, height[, mask]);

    Like `Prim.blit()`, but allows drawing only part of a texture.  `sx`, `sy`,
    `width` and `height` specify the section to be drawn.

Prim.drawCircle(surface, x, y, radius, color);

    Draws the outline of a circle.

Prim.drawEllipse(surface, x, y, rx, ry, color);

    Like `Prim.drawCircle()`, but draws an ellipse instead.

Prim.drawLine(surface, x1, y1, x2, y2, thickness, color[, color2]);

    Draws a line segment of given thickness from (x1,y1) to (x2,y2).  If
    `color2` is provided, draws a gradient line.

Prim.drawPoint(suface, x, y, color);

    Draws a single pixel.

Prim.drawRectangle(surface, x, y, width, height, thickness, color);

    Draws the outline of a rectangle with given thickness.

Prim.drawSolidCircle(surface, x, y, radius, color[, color2]);

    Draws a solid circle.  If `color2` is given, draws a gradient circle where
    `color` is the color in the center and `color2` is the color at the edges
    of the circle.

Prim.drawSolidEllipse(surface, x, y, rx, ry, color[, color2]);

    Like `Prim.drawSolidCircle()`, but draws an ellipse instead.  `rx` is the
    horizontal radius and `ry` is the vertical radius.

Prim.drawSolidRectangle(surface, x, y, width, height, color_ul[, color_ur, color_lr, color_ll]);

    Draws a solid rectangle.  If four colors are given instead of one, draws a
    gradient rectangle with each corner a different color.  Colors are given in
    clockwise order starting from the upper left.

Prim.drawSolidTriangle(surface, x1, y1, x2, y2, x3, y3, color[, color2, color3]);

    Draws a solid triangle.  If three colors are given instead of one, draws a
    gradient triangle with each vertex a different color.

Prim.fill(surface, color);

    Fills a surface with a specified color.  In practice, this has the same
    effect as drawing a rectangle of the specified color over the entire
    surface.


`Query` Object
--------------

The `Query` object provides games with the ability to perform complex queries
against the contents of arrays and other iterable collections.  One use case is
in battle engines: you could, for instance, query for only those battlers on
the enemy side, or use a query to narrow down the scope of status effects.
Even enemy AI code can benefit from queries!

    import { from, Query } from 'sphere-runtime';

If you're familiar with C#, the `from()` function works a lot like LINQ.  A
query is built from a number of predicates and mappings, and is then typically
processed using a `for...of` loop.  Each method returns a new Query object with
the corresponding operation appended so you can easily chain many different
operations into a single query.

For example, suppose you wanted to code an attack that damages all opposing
battlers whose level is a multiple of 5, but only hits 75% of the time.  That
could look like this:

    const targets = from(battlers)
        .where(v => v.isEnemyOf(attacker))
        .where(v => v.level % 5 == 0)
        .where(v => random.chance(0.75));
    for (const target of targets) {
        target.damage(move.power * attacker.strength);
    }

from(source[, ...]);

    Constructs and returns a `Query` which sources values from the JS array(s)
    or iterable(s) given by `source`.  Calling a reducer such as `.toArray()`
    on a query created this way will run it immediately and return the result.

    Note: You can specify more than one `source` to do a query over multiple
          collections as if they were a single list.

new Query();

    Constructs a Query object representing a deferrable query.  Unlike queries
    started using `from()` which always take values from the same places, when
    a reducer such as `toArray()` is called on a deferrable query, it returns a
    function you can call later to run the query on any set of sources you
    want.

    As an example:

        let hasEnergyDrinks = new Query()
            .over(member => member.items)
            .select(it => it.name)
            .anyIn(["Red Bull", "Monster"]);
        // later on...
        if (hasEnergyDrinks(enemyParty))
            stealFrom(enemyParty, "Monster");

Query#all(predicate);
Query#allIn(valueList);

    Runs the query and returns true if and only if all items match `predicate`
    or any value in `valueList`.  Otherwise it returns false.

    Note: The first item that doesn't match will terminate the query.  If there
          are no values to test, `true` is returned.

Query#any(predicate);
Query#anyIn(valueList);
Query#anyIs(value);

    Runs the query and returns true if any item matches the specified predicate
    (see `Query#where`) or value(s).

    Note: The first item that matches will terminate the query.  If there are
          no values to test, `false` is returned.

Query#ascending([keySelector]);
Query#descending([keySelector]);

    Calls `keySelector` to get a sort key for each value and sorts the values
    in ascending or descending order by key.  If no key selector is provided,
    the value itself will be used as the key.

    Note: Queries with sort operators in them will take longer to run and use
          more memory while running since they have to create a new temporary
          array internally to store the sorted values.  Keep this in mind when
          querying large collections.

Query#besides([callback]);

    Calls `callback` for each value that passes through.  This is useful if you
    need to perform ancillary actions in the middle of a query; for example,
    tallying intermediate results.

    Note: Avoid causing side effects that modify the query source.  Bad things
          can happen otherwise! (such as: the pig eating you)

Query#count([keySelector]);

    Runs the query and counts the results.  If no `keySelector` is provided,
    this method simply returns the total number of results.  Otherwise,
    `keySelector` is called for each result and values with different keys will
    be counted separately.  In this case, an object is returned with one entry
    for each unique key:

        let counts = from([ "pig", "cow", 812, "ape", 1208 ])
            .count(it => typeof it);
        // returns: { string: 3, number: 2 }

Query#drop(count);

    Filters out the first `count` results, passing the remainder on as-is.  The
    source array is not modified.

Query#find(predicate);

    Runs the query, calling `predicate` for each result, and returns the first
    value that matches.

    Note: The first value that matches the predicate will terminate the query.
          If there are no matching values, `undefined` is returned.

Query#first([mapper]);

    Runs the query and returns the value of the first result, or `undefined` if
    there are no results.  `mapper` is an optional function specifying how to
    transform the returned value (see `Query#select`).

    Note: The query is terminated immediately once the first result has been
          produced.

Query#forEach(callback);

    Runs the query, calling `callback` for each result.  The return value of
    the callback is ignored.  This is used to loop over the results of a query,
    the way you would loop over an array using arrayObj.forEach() in standard
    JavaScript.

Query#groupBy(keySelector);

    Runs the query and returns an object containing all query results grouped
    by key.  `keySelector` should return a string to use as the key for each
    group of values.  To illustrate how this works:

        let groups = from([ 1, "a", 2, "b", 3 ])
            .groupBy(it => typeof it);
        // returns: { number: [ 1, 2, 3 ], string: [ "a", "b" ] }

Query#last([mapper]);

    Runs the query and returns the value of the final result, or `undefined` if
    there are no results.  `mapper` is an optional function specifying how to
    transform the returned value (see `Query#select`).

Query#over(mapper);

    Similar to `Query#select`, but rather than being a 1:1 mapping, `over` maps
    each value to a list of values.  This is used to expand a query into
    subcollections, for example:

        havePotions = from(partyMembers)
            .over(member => member.items)
            .select(item => item.name)
            .anyIs('Potion');

Query#plus(value[, ...]);

    Injects additional values into the pipeline.  This differs from `over()`;
    while that operator replaces each value with values from a different list,
    `plus()` simply adds new values to the end of the stream.

    Note: More than one `value` can be provided and each one can be either a
          single value or an array of values.

Query#random(count);

    Takes `count` independent random samples from amongst the incoming values.
    The rest of the query will only see what was sampled.

    Note: Because the samples taken are independent, this can sample a result
          more than once; if you don't want duplicates, use `sample()` instead.

Query#reduce(reducer[, initialValue]);

    Runs the query and calls `reducer` for each result, assigning the return
    value to an internal accumulator at each step.  The current value of the
    accumulator is passed as the first argument to the reducer function, before
    the value.

    This is a fairly advanced operation, so to help illustrate, the following
    query calculates the sum of all numbers in the array `numbers`:

        sum = from(numbers).reduce((a, v) => a + v);

    Note: If `initialValue` is not given, the accumulator is initialized with
          the first query result; the reducer function will then not be called
          for that item.  If that behavior is not desirable, be sure to provide
          an initial value.

Query#remove([predicate]);

    Removes results from the source object or array.  `predicate` is optional;
    if provided, it should return true to remove the result, or false to keep
    it.  If no `predicate` is provided, all items satisfying the query will be
    removed.

Query#reverse();

    Takes all incoming values and reverses them so the rest of the query sees
    them in reverse order.

Query#sample(count);

    Takes `count` unique random samples from the pipeline and filters out the
    rest; the rest of the query will only see the sampled values.  This will
    not sample a given result more than once.

Query#select(mapper);

    Calls `mapper` for each item and uses whatever it returns as the new value
    for that item in subsequent operations.  The source array is not modified.

Query#shuffle();

    Shuffles all incoming values so that the rest of the query sees them in a
    random order.

Query#take(count);

    Uses only the first `count` items in subsequent operations and discards the
    rest.  The source array is not modified.

Query#tap(interceptor);

    Collects all results so far into an array and calls `interceptor` passing
    the array as the first parameter.  Any changes made to the array will be
    reflected in subsequent operations.

Query#thru(mapper);

    Similar to `tap`, but completely replaces the set of results with the array
    returned by `mapper`.

Query#toArray();

    Runs the query and returns the results in a JavaScript array object for
    later use.

Query#uniq([keySelector]);

    Filters out duplicate values.  If the mapping function `keySelector` is
    provided, it will be called for each result; only the first value for which
    a given key is selected will be kept.

Query#update(mapper);

    Writes new values back into the source object or array.  `mapper` is the
    mapping function to compute the value that gets written back.

    Note: As with `remove()`, `update()` cannot be used in a query containing
          whole-list transformations such as `shuffle()` or `reverse()`.

Query#where(predicate);

    Calls `predicate` for each value and keeps only those values for which the
    function returns `true`.  The source array is not modified.

Query#without(value[, ...]);

    Filters out the specified value(s).  Each `value` argument can be either a
    single value or an array of values.


`Random` Namespace
------------------

The `Random` namespace provides functions for generating different types of
random numbers.  This is a very useful convenience when you need high-quality
pseudorandom numbers for your game but don't necessarily need the full power of
the `RNG` class.

    import { Random } from 'sphere-runtime';

Random.chance(odds);

    Returns true or false depending on the given odds.  `odds` is a number in
    the range [0-1] specifying the odds of returning true.  For example, odds
    of 0.75 will return true 75% of the time.

Random.discrete(min, max);

    Returns a random integer uniformly distributed within the range [min,max].

Random.normal(mean, sigma);

    Returns a random floating point number from a normal distribution
    (sometimes called a bell curve) with expected value of `mean` and standard
    deviation `sigma`.

Random.sample(array);

    Returns a randomly chosen item from the specified array.

Random.string([length]);

    Returns a randomly generated string of consisting of `length` alphanumeric
    characters.  The generated string looks something like a YouTube video hash
    (e.g. YlHRHDrKS) and is useful for uniquely identifying things, for example
    to generate temporary filenames.  `length` defaults to 10 if not specified.

Random.uniform(mean, variance);

    Returns a random floating point value uniformly distributed around `mean`
    with an absolute maximum deviation ("give or take") specified by
    `variance`.


`Scene` Object
--------------

The Scene object encapsulates a powerful scene engine which can run multiple
operations in parallel, and then sync the timelines up as needed.  An example
of this would be where several characters need to move into place for a
cutscene, but may take differing amounts of time to get there.  The game can
fork the timeline once for each character, and then resync on the main
timeline, which will wait until all the forked timelines finish before
continuing.

Scene is originally based on the Scenario standalone cutscene engine for
Sphere v1, but has been updated to take advantage of Sphere v2 features and to
integrate more seamlessly with other Sphere v2 technologies.

    import { Scene } from 'sphere-runtime';

A scene consists of a chain of scenelet invocations, with optional forks and
resync points.  For example, supposing the scenelets used have been properly
defined, the scene below would cause the screen to fade out simultaneously and
the person `scott` to walk offscreen, and finally change the background music
only when both are complete:

    let myScene = new Scene()
        .fork()  // fork the timeline
            .fadeTo(new Color(0, 0, 0, 255), 2.0)  // 2 sec. fade
        .end()
        .walkOffscreen("scott")
        .resync()  // resync point - await completion of forks
        .changeBGM('maggieIsHungry');

This scene can be played back at any time by calling `myScene.run()`.  miniRT's
scene engine uses the threads module and by default, scenes are nonblocking.
See the documentation for `Scene#run()` below to find out how to play a scene
in blocking mode.

Scene.defaultPriority [R/W]

    The Dispatch priority to use for new scenes.  Changing this value allows
    you control where in the render order your cutscene elements (such as
    dialogue text boxes) will be drawn.  If this is not set, the default is
    0.0.

    Note: Setting this applies only to new `Scene` objects and will not affect
          the priority of objects that had already been created.

Scene.defineOp(name, def);

    Registers a new scenelet with the scene engine.  `name` is the name of the
    operation and should be a valid JavaScript identifier (although this is not
    enforced).  `def` is an object defining the scenelet, and should include
    the following function properties:

        def.start(scene[, ...]); [required]

            This is called once when the scenelet begins execution.  .start()
            should initialize any execution state for the scenelet and receives
            all arguments provided when the scenelet was added to the scene.

        def.finish(scene); [optional]

            .finish() is called once before execution continues on to the next
            operation.  This is useful if you have a scenelet that needs to do
            something specific to finalize the operation without needing to add
            a special case to .update().

        def.getInput(scene); [optional]

            Called once per game frame for the topmost scenelet to accept
            player input for that scenelet.  Only scenelets implementing a
            .getInput() callback can receive focus (see FocusTarget above).

        def.render(scene); [optional]

            Called once per frame to render anything related to the scenelet.
            A text scenelet might render a text box, for example.  Render order
            is determined by the order in which scenelets were started.

        def.update(scene); [optional]

            The scenelet's update function.  As with threads, this is called
            once per game frame and should return `true` to continue scenelet
            execution or `false` to finish.

            Note: If no update function is provided, the timeline immediately
                  proceeds to the next operation after running the scenelet's
                  start and finish callbacks.

    Each callback receives a reference to the Scene object which invoked it as
    its first argument, and its `this` binding is set to a unique object it can
    use to manage execution state for that invocation only.

new Scene([options]);

    Constructs a new scene definition.  The scene starts with no scenelets and
    will do nothing when run.  Calling any method other than .run() on the
    scene will add scenelets, and this is how you build a scene.

    options.inBackground [default: false]

        The scene will run as a background task.  This can be useful to set up
        animations you want to run continuously in the background without
        preventing the game from exiting naturally.

    options.priority [default: varies]

        The Dispatch priority of the scene.  See the Core API documentation,
        specifically the documentation for the `Dispatch` namespace, for more
        information on job priorities.

        Note: The default priority for new scenes is determined by the value of
              `Scene.defaultPriority` (see above).

Scene#running [R/O]

    `true` if scene execution is in progress, `false` if not.

Scene#doIf(predicate);

    `predicate` should be a function.  Any scenelets between the doIf() and its
    corresponding end() will be executed only if the predicate returns `true`.
    This works like an `if` statement in JavaScript.

Scene#doWhile(predicate);

    `predicate` should be a function.  Any scenelets between the doWhile() and
    its corresponding end() will be executed in a loop as long as the predicate
    returns `true`.  This works like a `while` statement in JavaScript.

Scene#end();

    A metascenelet which closes the open context.  Currently, metascenelets
    which open a context and therefore require an end() marker are:

        doIf()
        doWhile()
        fork()

Scene#fork();

    A metascenelet which forks the timeline.  This opens a new timeline to which
    all subsequent scenelets are added until a corresponding end() is
    encountered.  Forked timelines run in parallel with the timeline that
    spawned them.

Scene#restart();

    Restarts a scene from the beginning, regardless of whether or not it was
    running at the time restart() is called.

Scene#resync();

    A metascenelet which adds a resync point to the open timeline.  Timelines
    may be forked to run operations in parallel, but it is sometimes necessary
    to wait until several simultaneous operations have completed before
    continuing.  Resync points do just that, halting the timeline they are found
    on until all timelines forked from it have completed.

    There is an implicit resync point at the end of a timeline.  In practice,
    this means that a scene will not complete until all of its timelines have
    completed.

Scene#run();

    Starts playing the scene and returns a promise which resolves once playback
    ends.  This function can be used with `await`.

Scene#stop();

    Stops playing the scene.  This works like the Stop button on a CD player:
    The next time the scene is run, it will start from the beginning.

    Note: Stopping a scene this way will cause the promise returned by `run()`
          to resolve normally.  It will not be rejected as this is not an error
          condition.


`Thread` Object
---------------

Using `Thread`, independent threads can be started and stopped at will, each
with its own update and render handler.  This allows game processes to run in
parallel.  For example, you might have a thread to run the in-game clock and
another to run your battle system.

While `Thread` objects are not true, native threads (JS is single-threaded!),
they come close.  An update handler can freely `await` on the result of a
promise and other threads will happily continue on their way, all without
blocking the event loop.

    import { Thread } from 'sphere-runtime';

Thread.join(thread[, ...]);

    Returns a promise that resolves upon termination of one or more threads.
    Works with `await`.  If multiple threads are specified, the promise will
    not resolve until all of them have finished.  If all specified threads are
    already stopped, the promise resolves immediately.

new Thread(options);

    Constructs a Thread object.  This can only be invoked as a `super()` call;
    calling this directly as `new Thread()` will produce a TypeError.

    options.inBackground [default: false]

        The thread represents a background task.  Specify this for threads you
        want to run in the background without keeping the event loop alive past
        its time.

    options.priority [default: 0.0]

        The thread priority.  Higher priority threads will be updated
        sooner and rendered later in a frame.  Especially useful to enforce
        rendering order.

Thread#hasFocus [R/O]

    `true` if the thread has input focus, `false` otherwise.

Thread#priority [R/O]

    Gets the priority of the thread.  This is set when the thread is created
    and can't be changed afterwards.

Thread#running [R/O]

    `true` if this thread is running (even if it's awaiting a promise),
    otherwise `false`.

Thread#on_startUp(); [event handler]

    Implement this in your subclass to provide code to run each time the thread
    starts running.  This allows you to perform asynchronous operations on
    thread start, since you can't use `await` in a constructor.

Thread#on_shutDown(); [event handler]

    Implement this in your subclass to provide code to run when the thread
    terminates.  This handler will run both if the thread is stopped manually
    (see `Thread#stop()`) and as a result of the event loop exiting, e.g., if
    the user closes the game window.

Thread#on_inputCheck(); [event handler]

    Implement this in your subclass to provide code to accept user input.  This
    will be called once per frame, but only if the thread has first been given
    the focus by calling `Thread#takeFocus()`.

Thread#on_render(); [event handler]

    Implement this in your subclass to provide code to draw objects associated
    with the thread.  Renders may be skipped in order to maintain the game's
    desired frame rate, so you'll want to avoid putting any "business logic" in
    here.

    IMPORTANT: Do not use `await` in the render handler.  Doing so is undefined
               behavior; bad things will happen.

Thread#on_update(); [event handler]

    Implement this in your subclass to provide code to be executed every frame.
    The value of `Sphere.frameRate` (see the Core API documentation) determines
    how often updates will be done.

Thread#pause();

    Pauses the thread.  While a thread is paused, its update and input check
    callbacks won't be called, but render calls will continue to be performed
    as usual.  If the thread is in the middle of an update when this is called,
    that update will still run to completion.

    Note: Paused threads can still keep the event loop alive unless they were
          created with the `inBackground` option enabled.

Thread#resume();

    Resumes the thread after it was paused with Thread#pause().  If the thread
    is not paused, this does nothing.

Thread#start();

    Starts the thread.  All threads are created in stopped state and must be
    started by calling Thread#start() before their handlers will execute.
    Returns a promise that resolves after the thread's `on_startUp()` handler
    has run to completion.

Thread#stop();

    Stops the thread.  Any outstanding Thread#join() promises for this thread
    will resolve and Sphere will stop calling the thread handlers.  If the
    thread currently has input focus, calling this also yields the focus.

    Note: If the thread's update handler is paused at an `await` expression
          when this method is called, the asynchronous operation being awaited
          will not be canceled and that update will still run to completion.

Thread#takeFocus();

    Gives this thread focus.  Only the thread in focus will receive inputCheck
    events (see Thread#on_inputCheck() above).  If a higher-priority entity
    already has focus when this is called, the focus will be given only once
    the higher-priority task(s) yield.

    Note: This can take the focus away from any code holding a FocusTarget
          (see above), not just other threads.

Thread#yieldFocus();

    If this thread currently has focus, calling this gives focus back to the
    previously-focused entity.  Nothing happens if the thread doesn't currently
    have focus.


`Tween` Object
--------------

The `Tween` object provides a way to manage simple animations.  You specify an
object to animate when constructing the Tween and then whenever you need to
animate it, you call one of the easing methods with the property values you
want to change and the Tween engine will take care of the rest, using
interpolation to gradually change the value over the course of several frames.

    import { Tween, Easing } from 'sphere-runtime';

Tweens are asynchronous in nature; the `ease` methods simply set an animation
to start and then return immediately.  If you need to wait until an animation
is finished to do something, each method returns a promise that resolves only
once the animation is complete.

new Tween(object[, easing_type]);

    Constructs a Tween which can be used to animate properties of the specified
    `object`.  `easing_type` specifies the curve that values should follow on
    their way to the new value and can be one of:

        Easing.Back
        Easing.Bounce
        Easing.Circular
        Easing.Cubic
        Easing.Elastic
        Easing.Exponential
        Easing.Linear
        Easing.Quadratic
        Easing.Quartic
        Easing.Quintic
        Easing.Sine

    The default is `Easing.Sine`, which animates according to the trigonometric
    sine (`Math.sin`) function.

Tween#easeIn(newValues, numFrames); [async]

    Starts an animation such that the "tail" of the easing function (that is,
    the slower part of the animation) is applied at the beginning of the
    movement.  `newValues` is an object naming the properties to animate and
    the new values they should take by the end of the animation.

Tween#easeOut(newValues, numFrames); [async]

    Starts an animation such that the "tail" of the easing function is applied
    at the end of the movement.  `newValues` is an object naming the properties
    to animate and the new values they should be tweened to.

Tween#easeInOut(newValues, numFrames); [async]

    Starts an animation which is a combination of `easeIn` and `easeOut`;
    movement will slow down in the middle of the animation before speeding up
    again.  `newValues` is an object naming the properties to animate and the
    new values they should be tweened to.


`XML` Namespace
---------------

The `XML` namespace provides functions to parse XML-formatted data and build a
document object model (DOM) from it.  This module is based on the MIT-licensed
"sax js" parser.  The API is simple but should cover most use cases.

    import { XML } from 'sphere-runtime';

XML.parse(text);

    Parses XML text provided to the function and returns a DOM built from it.
    This function will throw if an error occurs during parsing, for example due
    to invalid or malformed XML.

    The DOM generated by this function is defined as follows:

        1. The DOM object has a property, `nodes`, which is an array of node
           objects.  Its `type` is set to "root".
        2. A node's `type` may be either "tag", "text", or "comment".
        3. A "tag" node represents an XML element and has its own `nodes`
           property, whose entries follow Rule 2 above.
        4. "text" and "comment" nodes are leaves.  They do not have a `nodes`
           property; instead they have a `text` string property with their
           content.

XML.readFile(fileName); [ASYNC]

    Loads XML text from a file asynchronously and returns a promise for a DOM
    built from it.

    Note: The return value and throw semantics of this function are identical
          to those of `XML.parse()` above.  In cases where `XML.parse` would
          throw, `XML.readFile`, being async, will reject its promise instead.
